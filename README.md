# proxy
Proxy server
https://habr.com/post/142527/   


## TCP/IP proxy на Go
Системное программирование,
Go
Я снова вернулся к любимой задаче для освоения новых языков. После написания движка для блога на Go, захотелось снова поразмять пальцы, болезный TCP/IP proxy/debugger теперь написан на Go.

Вкратце, TCP/IP proxy — это программа, которая умеет принимать соединения и «пробрасывать» их на указанный адрес. Попутно ведутся логи переданных данных. Это очень удобно при отладке различных самодельных сетевых протоколов.

В плане функциональности версия на Go, как и эрланговская, ведет три лога: двунаправленный шестнадцатеричный дамп и бинарные логи в обоих направлениях, «от» и «к» удаленному хосту. Питоновская версия бинарные логи не ведет.

Конечно, все многопоточно. И так как в Go параллельное программирование настолько просто (и безопасно), количество параллельных активностей для каждого соединения даже больше, чем в версии на Эрланге.

На Эрланге для каждого соединения работали следующие четыре потока:
двунаправленный дамп-логгер
два потока для двоичных логов принимаемых и посылаемых данных
главный поток, мультиплексирующий чтение из локального и удаленного сокетов

В версии на Go немного иначе:
двунаправленный дамп-логгер
два потока для двоичных логов принимаемых и посылаемых данных
два независимых потока для чтения из локального и удаленного сокета

Итого, 5.

В обоих случаях потоки чтения логируют данные, посылая сообщения потокам-логгерам. Конечно, нет никаких глупостей типа мьютексов или условных переменных. Проблемы согласования элегантно решаются через каналы Go.

Ниже привожу исходник. Он отличается от того, что в репозитории, наличием обильных комментариев. Для людей, не очень знакомых с Go, могут быть интересны некоторые моменты.


Повторюсь, каждое соединения обслуживается пятью потоками. И сделал я это не ради прикола. Просто мне показалось, что логически есть явно независимые подзадачи, которые было бы логично запустить параллельно. Если б я писал все на C++/boost, я б скорее всего замутил все одном потоке для каждого соединения (а может быть и вся программа была бы чисто однопотоковой через какие-нибудь изощренные библиотеки мультиплексирования), и не исключено, что на C++ в итоге еще и работало бы быстрее, несмотря на один поток. Но я хочу сказать не об этом. Go подталкивает на многопоточное программирование (а не отталкивает, как C++, даже на стероидах нового стандарта). Так или иначе, будут задачи, где удобная многопоточность станет ключевым фактором.

Запустить можно так (требуется как минимум Go релиз 1):

go run gotcpspy.go -host pop.yandex.ru -port 110 -local_port 8080

Выведется:

Start listening on port 8080 and forwarding data to pop.yandex.ru:110

Затем, если в другом окне ввести:

telnet localhost 8080

и ввести, например, "USER test" "ENTER" и "PASS none" "ENTER", то будут созданы три лога (дата в имени будет, конечно, другая).

Общий лог log-2012.04.20-19.55.17-0001-192.168.1.41-49544-213.180.204.37-110.log:

    Connected to pop.yandex.ru:110 at 2012.04.20-19.55.17
    Received (#0, 00000000) 38 bytes from 192.168.1.41-49544
    00000000  2b 4f 4b 20 50 4f 50 20  59 61 21 20 76 31 2e 30  |+OK POP Ya! v1.0|
    00000010  2e 30 6e 61 40 32 36 20  48 74 6a 4a 69 74 63 50  |.0na@26 HtjJitcP|
    00000020  52 75 51 31 0d 0a                                 |RuQ1..|
    Sent (#0) to [--1]-8080
    Received (#0, 00000000) 11 bytes from [--1]-8080
    00000000  55 53 45 52 20 74 65 73  74 0d 0a                 |USER test..|
    Sent (#0) to 192.168.1.41-49544
    Received (#1, 00000026) 23 bytes from 192.168.1.41-49544
    00000000  2b 4f 4b 20 70 61 73 73  77 6f 72 64 2c 20 70 6c  |+OK password, pl|
    00000010  65 61 73 65 2e 0d 0a                              |ease...|
    Sent (#1) to [--1]-8080
    Received (#1, 0000000B) 11 bytes from [--1]-8080
    00000000  50 41 53 53 20 6e 6f 6e  65 0d 0a                 |PASS none..|
    Sent (#1) to 192.168.1.41-49544
    Received (#2, 0000003D) 72 bytes from 192.168.1.41-49544
    00000000  2d 45 52 52 20 5b 41 55  54 48 5d 20 6c 6f 67 69  |-ERR [AUTH] logi|
    00000010  6e 20 66 61 69 6c 75 72  65 20 6f 72 20 50 4f 50  |n failure or POP|
    00000020  33 20 64 69 73 61 62 6c  65 64 2c 20 74 72 79 20  |3 disabled, try |
    00000030  6c 61 74 65 72 2e 20 73  63 3d 48 74 6a 4a 69 74  |later. sc=HtjJit|
    00000040  63 50 52 75 51 31 0d 0a                           |cPRuQ1..|
    Sent (#2) to [--1]-8080
    Disconnected from 192.168.1.41-49544
    Disconnected from [--1]-8080
    Finished at 2012.04.20-19.55.17, duration 5.253979s

Двоичный лог исходящих данных log-binary-2012.04.20-19.55.17-0001-192.168.1.41-49544.log:

    USER test
    PASS none

Двоичный лог входящих данных log-binary-2012.04.20-19.55.17-0001-213.180.204.37-110.log:

    +OK POP Ya! v1.0.0na@26 HtjJitcPRuQ1
    +OK password, please.
    -ERR [AUTH] login failure or POP3 disabled, try later. sc=HtjJitcPRuQ1

Теперь измерим производительность. Прокачаем файл напрямую, а потом через эту программу.

Качаем напрямую (файл размером около 72MB):

    time wget http://www.erlang.org/download/otp_src_R15B01.tar.gz
    ...
    Saving to: `otp_src_R15B01.tar.gz'
    ...
    real	1m2.819s

Теперь закачаем через программу, предварительно запустив ее:

    go run gotcpspy.go -host=www.erlang.org -port=80 -listen_port=8080

Качаем:

    time wget http://localhost:8080/download/otp_src_R15B01.tar.gz
    ...
    Saving to: `otp_src_R15B01.tar.gz.1'
    ...
    real	0m56.209s

На всякий случай, можно сравнить результаты:

    diff otp_src_R15B01.tar.gz otp_src_R15B01.tar.gz.1

У меня файлы одинаковые, значит все работает верно.

Теперь время. Я повторял эксперимент несколько раз (на Mac Air), и, что удивительно, закачка через программу всегда была не то, чтобы медленнее, а даже немного быстрее. Например, напрямую — 1m2.819s, через программу — 0m56.209s. Единственное объяснение, что wget возможно работает в один поток, а программа принимает данные из локального и удаленного сокета в два потока, что может давать небольшое ускорение. Но, разница все равно минимальна, и возможно на другой машине или сети ее будет не видно, но главное, что работает как минимум не медленнее, чем напрямую, несмотря на создание в процессе передачи весьма массивных логов.

Итак, пока среди трех вариантов такой программы, на Питоне, Эрланге и Go, последняя мне нравится больше всего.

Как мне показалось, неплохой эксперимент с параллельностью в Go.
